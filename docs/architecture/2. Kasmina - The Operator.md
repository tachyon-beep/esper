# **Detailed Design Document: Kasmina Operator Subsystem**

**Version:** 0.1a
**Status:** Drafting
**Date:** 23 June 2025
**Author:** John Morrissey, Gemini AI

## **1. Introduction**

### **1.1. Purpose & Scope**

This document provides the formal detailed design for **Kasmina**, the foundational execution layer of the Esper Morphogenetic Platform. The Kasmina subsystem consists of distributed KasminaSeed modules responsible for the low-level mechanics of monitoring neural network health, executing their own adaptation lifecycle, and safely integrating ("grafting") new computational capacity into a live host network.

This specification serves as the canonical reference for the implemented system. The scope is strictly limited to the operational mechanics of the KasminaSeed; it does not cover the strategic decision-making policies or the coordination logic, which are the exclusive domain of Tamiyo (TamiyoController).

### **1.2. Architectural Goals & Principles**

The Kasmina architecture is designed to adhere to the following core principles:

* **Surgical Precision:** Adaptations must be targeted at specific, verifiable computational bottlenecks. By isolating and modifying only the underperforming components, Kasmina avoids disrupting well-functioning parts of the network.  
* **Operational Safety:** The primary goal is to *do no harm*. All interventions are executed via a multi-stage, gated lifecycle that tests new components in isolation before they are allowed to influence the network's gradients or outputs.  
* **Modularity & Extensibility:** The system must be composed of clearly defined, pluggable components (e.g., Grafting Strategies) to facilitate experimentation and future evolution.  
* **Separation of Concerns:** Kasmina handles the *how* (the mechanics of adaptation). The strategic *what*, *when*, and *where* are the exclusive responsibilities of the Tamiyo controller. The KasminaSeed is a predictable, deterministic operator that executes commands given to it by the controller.

## **2. System Architecture**

The Kasmina subsystem uses a **chunked architecture** to monitor and adapt neural networks. This design allows for efficient, parallel processing of large activation tensors while maintaining the integrity of the original network structure.

### **2.1. Architectural Model: The Chunked Architecture**

The foundational principle of the Kasmina architecture is the partitioning of a layer's activation tensor into multiple, independently monitored **chunks**. This strikes an optimal balance between the surgical precision of a true per-node model and the computational efficiency required for large-scale networks.

* **Operator-Controlled Granularity:** An operator has direct control over the level of precision via the --seeds_per_layer parameter, which determines how many chunks a layer is divided into.  
  * **Ultra-fine (Per-Node) Mode:** Setting seeds_per_layer equal to the layer's hidden_dim results in a chunk size of 1, providing maximum diagnostic precision for detecting "dead neurons".  
  * **Coarse Mode:** Setting seeds_per_layer to a small number (e.g., 4 or 8) provides efficient, high-level monitoring suitable for very large networks.  
* **Data Flow (Split -> Process -> Concatenate):** During a forward pass, the activation tensor of a layer is split into non-overlapping chunks. Each chunk is passed to its corresponding KasminaSeed for processing. The outputs from all seeds are then concatenated back together, re-forming the full activation tensor with perfect dimensionality preservation. This ensures that the operations of one seed are structurally isolated from all others.

### **2.2. Visual Data Flow**

The data flow within a Kasmina-enabled layer is deterministic and precise, ensuring perfect structural integrity.

graph TD  
    A[Activation Vector<br>(batch_size, hidden_dim)] --> B{torch.split<br>into N chunks};  
    B --> C1[Chunk 0<br>(batch_size, chunk_size_0)];  
    B --> C2[...];  
    B --> C3[Chunk N-1<br>(batch_size, chunk_size_N-1)];  

    C1 --> D1["KasminaSeed(layer, 0)<br>Processes Chunk 0"];  
    C2 --> D2["..."];  
    C3 --> D3["KasminaSeed(layer, N-1)<br>Processes Chunk N-1"];  
      
    D1 --> E1[Processed Chunk 0];  
    D2 --> E2["..."];  
    D3 --> E3[Processed Chunk N-1];  
      
    E1 --> F{torch.cat(dim=1)};  
    E2 --> F;  
    E3 --> F;  
      
    F --> G[Final Output Vector<br>(batch_size, hidden_dim)];

This diagram illustrates the process: an incoming tensor is deconstructed into smaller, manageable chunks, each handled by a specialist seed, before being perfectly reconstructed. This mechanism is the core of Kasmina's ability to perform parallel monitoring and intervention without compromising the network's structural integrity.

## **3. Core Component: KasminaSeed**

The Kasmina architecture is implemented entirely by the KasminaSeed module. There are no other components within the Kasmina subsystem. These distributed agents are coordinated directly by the Tamiyo controller.

### **3.1. KasminaSeed (The Kasmina Operator)**

The KasminaSeed is the core atomic unit of the Kasmina architecture. An instance of this module is created for each chunk in a monitored layer. It is a stateful agent that executes the full lifecycle of adaptation based on direct commands from Tamiyo.

* **Responsibilities:**  
  * **State Management:** Each seed is a self-contained state machine, progressing through its lifecycle. Its internal state dictates its behaviour in the computational graph.  
  * **Telemetry Generation:** In its DORMANT state, it buffers its assigned activations. At the end of each epoch, it calculates and pushes a rich, multi-metric health signal directly to Tamiyo (or via an event bus Tamiyo subscribes to).  
  * **Child Network Management:** When commanded to germinate by Tamiyo, it manages the initialisation of its child network (the specified blueprint).  
  * **Grafting Execution:** It executes the GraftingStrategy specified by Tamiyo to smoothly and safely blend its child network's output into the main computational graph.  
* **Interaction with Controller:** Each KasminaSeed instance must be initialized with a handle or reference to the Tamiyo controller instance. It uses this handle for all "upwards" communication, such as registering itself, pushing telemetry, and accessing its activation buffer (which is managed by Tamiyo).

## **4. Telemetry and Control Interface**

The interface between the Kasmina seeds (KasminaSeed instances) and the Tamiyo controller is designed for a clean separation of concerns, enabling a responsive, event-driven control loop.

### 4.1. Health Signal (Kasmina â†’ Tamiyo)

The interface between the Kasmina seeds (KasminaSeed instances) and the Tamiyo controller is designed for a clean separation of concerns, enabling a responsive, event-driven control loop.

* **Push-Based Model:** The target architecture is a **push-based** model. At the end of each training epoch, every DORMANT KasminaSeed proactively calculates its health and pushes a report to an event bus that Tamiyo subscribes to. This provides Tamiyo with a complete, real-time health map of the network.
* **Multi-Metric Signal:** The health signal is a dictionary of diagnostic metrics, allowing Tamiyo to understand the *nature* of a bottleneck. This includes:
  * `chunk_variance`: Indicates a "stuck" or "dead" chunk.
  * `dead_node_ratio`: Measures the proportion of inactive neurons within the chunk.
  * `avg_inter_node_correlation`: Suggests functional redundancy.
* **Blueprint Performance Metrics for Field Reports:** During the `EVALUATING` and `FINE-TUNING` lifecycle stages, the KasminaSeed is responsible for measuring blueprint-specific performance metrics. These metrics, such as `max_latency`, `avg_memory`, and `gradient_variance`, are included in its status reports to Tamiyo. This provides Tamiyo with the necessary data to construct a complete `FieldReport` for the Karn architect, ensuring the outer reinforcement loop is closed with rich, real-world performance data.

### **4.2. Control Commands (Tamiyo â†’ Kasmina)**

The primary control pathway is a direct command from Tamiyo to a specific KasminaSeed instance. Tamiyo maintains the registry of all seeds and can therefore address them directly.

* **KasminaSeed.request_germination(blueprint_id, grafting_strategy):** This is the method Tamiyo calls directly on a specific seed to initiate an adaptation. Tamiyo provides the full specification: *what* to grow (blueprint_id) and *how* to integrate it (grafting_strategy). The seed then transitions its internal state to GERMINATED and awaits its turn in the training queue managed by Tamiyo.  
* **KasminaSeed.cancel_germination():** This method allows Tamiyo to intelligently retract a previous request for a seed that is currently in the GERMINATED or TRAINING state. The seed will then transition its state to CANCELLED and subsequently back to DORMANT.

The asynchronous interaction between the two systems is crucial for efficiency and responsiveness.

sequenceDiagram  
    participant Kasmina (Seeds)  
    participant EventBus  
    participant Tamiyo

    loop Every Epoch  
        Kasmina (Seeds)-->>EventBus: Push Health Reports  
    end  
      
    Tamiyo->>EventBus: Consume Health Reports  
    Note over Tamiyo: Analyzes data, detects plateau,<br>identifies critical node 'A', adds its<br>seed to internal germination queue.  
      
    alt Training Slot is Free  
      Tamiyo->>Kasmina (Seed A): request_germination(bp_X, gs_Y)  
      Note over Kasmina (Seed A): State -> GERMINATED -> TRAINING  
    end

    Note over Tamiyo: A different seed, 'B', is in the queue.<br>New health reports show its node has self-corrected.  
    Tamiyo->>Kasmina (Seed B): cancel_germination()  
    Note over Kasmina (Seed B): State -> CANCELLED -> DORMANT

## **5. The Authoritative Seed Lifecycle**

The lifecycle is the core process model for every adaptation, ensuring a balance of safety and effectiveness. It is executed by the KasminaSeed and orchestrated by Tamiyo. Each stage represents a gate that must be passed before proceeding.

## **5. The Authoritative Seed Lifecycle**

The lifecycle is the core process model for every adaptation, ensuring a balance of safety and effectiveness. It is an **11-stage** state machine executed by the `KasminaSeed` and orchestrated by the `Tamiyo` controller. Each stage represents a gate that must be passed before proceeding.

Crucially, major state transitions are not autonomous. A seed signals its readiness to advance to `Tamiyo`, and the controller makes the final decision to issue a transition command at the end of an epoch, ensuring all state changes are discrete and centrally managed.

| State | Emoji | Trigger | Key Behavior | Risks Mitigated by this State | Next State |
| :---- | :---- | :---- | :---- | :---- | :---- |
| **DORMANT** | âšª | Initial state | Buffers activations, pushes health reports to Tamiyo at the end of each epoch. Identity pass-through in the computational graph. | Inaction; failing to detect a critical bottleneck. | GERMINATED |
| **GERMINATED** | ðŸŒ± | `request_germination()` from Tamiyo | A "waiting" state. The seed is queued for adaptation and awaits promotion from the training queue, which is managed by Tamiyo. | Resource contention from training multiple seeds at once; training instability. | TRAINING or CANCELLED |
| **TRAINING** | ðŸ§‘â€ðŸ« | Promotion from queue by Tamiyo | Learns a self-supervised reconstruction task (e.g., MSE). It has **zero impact** on the main network's forward pass or gradients. Upon passing the reconstruction test, it signals readiness to `Tamiyo` and awaits a command to enter the `GRAFTING` state. | An unstable or poorly initialized blueprint affecting the live model's performance. | GRAFTING, CULLED, or CANCELLED |
| **GRAFTING** | ðŸ”— | Command from `Tamiyo` (after passing reconstruction) | Blends its child network's output with the original activation via a smooth alpha ramp. Upon ramp completion, it signals readiness to `Tamiyo` and awaits a command to enter the `STABILIZATION` state. | Sudden performance drops or gradient shock caused by an abrupt change in the computational graph. | STABILIZATION |
| **STABILIZATION** | ðŸ› ï¸ | Command from `Tamiyo` (after alpha ramp) | All child network parameters are temporarily frozen to allow the host network's dynamics (e.g., BatchNorm statistics) to settle. After a set number of steps, it signals readiness to `Tamiyo` and awaits a command to enter the `EVALUATING` state. | Inaccurate performance evaluation due to an unsettled network state. | EVALUATING |
| **EVALUATING** | ðŸ”¬ | Command from `Tamiyo` (after stabilization) | Measures the blueprint's impact on global validation metrics without any training to get a clean performance signal. Based on the outcome, it signals readiness for `FINE-TUNING` or `CULLING` to `Tamiyo` and awaits a command. | Wasting resources fine-tuning a harmful blueprint. | FINE-TUNING or CULLED |
| **FINE-TUNING** | ðŸ“» | Command from `Tamiyo` (after positive evaluation) | Switches training to the main task loss (e.g., Cross-Entropy) to align the blueprint with the global objective. It is evaluated continuously until it demonstrates global improvement or fails a performance gate. | A blueprint that is good at reconstruction but useless for the main task. | FOSSILIZED or CULLED |
| **FOSSILIZED** | ðŸ¦´ | Command from `Tamiyo` (after global improvement) | Parameters are permanently frozen. The adaptation is successful and integrated into the host model. The seed's work is complete. | N/A (Success state) | *Terminal* |
| **CULLED** | ðŸ¥€ | Command from `Tamiyo` (after failing a gate) | **Failure state.** The blueprint is deactivated and discarded due to poor performance. The slot is placed under a temporary embargo by Tamiyo. | "Thrashing"â€”repeatedly trying to fix a persistently unstable part of the network. | DORMANT |
| **CANCELLED** | ðŸ›‘ | `cancel_germination()` from Tamiyo | **Stop state.** Immediately ceases all activity and discards any trained child network. Occurs before the parent network is impacted. | Wasting compute on a now-unnecessary adaptation; occupying a training slot needed elsewhere. | DORMANT |
| **ROLLED_BACK** | âª | Emergency rollback command from `Tamiyo` | **Emergency Failure State.** Immediately halts all activity and discards the child network following a catastrophic model instability event. This state is for reporting purposes after a system-level checkpoint restore. | A dangerously unstable blueprint permanently corrupting the model state or training run. | *Terminal* |

### **4.2 State Transition Diagram**

```mermaid
stateDiagram-v2
    [*] --> DORMANT: Initial state
    DORMANT --> GERMINATED: request_germination() from Tamiyo
    GERMINATED --> TRAINING: Command from Tamiyo
    GERMINATED --> CANCELLED: cancel_germination() from Tamiyo
    TRAINING --> GRAFTING: Command from Tamiyo (after reconstruction)
    TRAINING --> CULLED: Command from Tamiyo (reconstruction failure)
    TRAINING --> CANCELLED: cancel_germination() from Tamiyo
    GRAFTING --> STABILIZATION: Command from Tamiyo (alpha ramp complete)
    STABILIZATION --> EVALUATING: Command from Tamiyo (stabilization complete)
    EVALUATING --> FINE-TUNING: Command from Tamiyo (positive evaluation)
    EVALUATING --> CULLED: Command from Tamiyo (negative evaluation)
    FINE-TUNING --> FOSSILIZED: Command from Tamiyo (global improvement)
    FINE-TUNING --> CULLED: Command from Tamiyo (fails gate)
    FOSSILIZED --> DORMANT: Reset to dormant
    CULLED --> DORMANT: Reset to dormant (after embargo)
    CANCELLED --> DORMANT: Reset to dormant
    TRAINING --> ROLLED_BACK: Emergency rollback command
    GRAFTING --> ROLLED_BACK: Emergency rollback command
    STABILIZATION --> ROLLED_BACK: Emergency rollback command
    EVALUATING --> ROLLED_BACK: Emergency rollback command
    FINE-TUNING --> ROLLED_BACK: Emergency rollback command
    ROLLED_BACK --> [*]: Terminal state
```

## **6. Pluggable Grafting Strategies**

Grafting is the critical and delicate process of integrating the new seed. The KasminaSeed implements a pluggable strategy pattern to allow for different integration behaviors, based on the strategy name passed to it by Tamiyo.

* **Fixed Ramp Grafting:** The baseline, most predictable strategy. It increases the blending factor alpha linearly over a fixed number of steps. It is used when the network is stable and a predictable integration is desired.  
* **Performance Linked Grafting:** An optimistic strategy that accelerates grafting if the seed's self-supervised reconstruction loss improves quickly. This can speed up the integration of good seeds, but carries the risk of rewarding behavior (good reconstruction) that may not align with the final task performance.  
* **Drift Controlled Grafting:** A key safety strategy designed for unstable networks. It constantly monitors model weight drift (a proxy for stability) and will **automatically pause** the grafting process if drift exceeds a safe threshold. It ensures that new components are not introduced while the host network is already in a turbulent state.  
* **Grad Norm Gated Grafting:** Another crucial safety strategy. It monitors the norm of the model's gradients and **pauses** grafting if gradients are exploding or vanishing. This prevents integration during periods of acute training instability.

Kasmina defines her grafting strategies as Enums, which are passed to the `KasminaSeed` when germination is triggered. This allows for a clean, extensible way to add new strategies in the future without modifying the core seed logic. Tamiyo selects the appropriate grafting strategy based on the current state of the host network and the specific characteristics of the seed being grafted. The KasminaSeed is designed to execute any of these strategies, allowing Tamiyo to change strategies dynamically as needed.

## **7. API Contracts & Data Structures**

Key data structures and interfaces are defined to ensure stable, versioned interaction between the Kasmina operators and the Tamiyo controller.

```python
    # --- Core Component Interface ---
    from enum import Enum

    class GraftingStrategy(Enum):
        FIXED_RAMP = "FixedRampGrafting"
        PERFORMANCE_LINKED = "PerformanceLinkedGrafting"
        DRIFT_CONTROLLED = "DriftControlledGrafting"
        GRAD_NORM_GATED = "GradNormGatedGrafting"

    class KasminaSeed(nn.Module):  
        """A stateful agent that monitors a chunk and executes the adaptation lifecycle."""

        def __init__(self, seed_id: tuple, chunk_dim: int, controller: "TamiyoController", **kwargs):  
            ...

        def forward(self, x: torch.Tensor, y: torch.Tensor | None = None) -> torch.Tensor: ...  
        
        def push_health_signal(self) -> None:   
            """Calculates health metrics and pushes them to the controller."""  
            ...

        def request_germination(self, blueprint_id: str, grafting_strategy: str) -> bool:  
            """Called by Tamiyo to initiate the lifecycle. Transitions state to GERMINATED. Returns success."""  
            ...

        def cancel_germination(self) -> bool:  
            """Called by Tamiyo to cancel a queued/training request. Transitions state to CANCELLED. Returns success."""  
            ...  
        # ... internal lifecycle methods for each state

    # --- Controller Interface (for context) ---

    class TamiyoController:  
        """The central controller, responsible for strategy and coordination."""  
        def **init**(self):  
            self.seed_registry: dict[tuple, KasminaSeed] = {}  
            self.activation_buffers: dict[tuple, deque] = {}  
            self.germination_queue: list[tuple] = []  
            # ...  

        def register_seed(self, seed: KasminaSeed) -> None:  
            """Adds a new seed to the registry upon network creation."""  
            ...

    # --- Configuration & Strategy Interfaces ---

    @dataclass(frozen=True)  
    class GraftingConfig:  
        """Immutable configuration for all grafting strategies and lifecycle timings."""  
        fixed_steps: int = 30  
        high_drift_threshold: float = 0.12  
        grad_norm_lower: float = 0.1  
        grad_norm_upper: float = 1.0  
        # ... other thresholds for stabilization, fine-tuning patience, etc.

    class GraftingStrategy(ABC):  
        """Abstract base class for all integration strategies."""  
        def **init**(self, seed: KasminaSeed, config: GraftingConfig): ...  

        @abstractmethod  
        def update(self) -> float: # Returns the new alpha value for the current step  
            ...
```
