# **Detailed Design Document: Kasmina Operator Subsystem**

**Version:** 0.1a
**Status:** Drafting
**Date:** 23 June 2025
**Author:** John Morrissey, Gemini AI

## **1. Introduction**

### **1.1. Purpose & Scope**

This document provides the formal detailed design for **Kasmina**, the foundational execution layer of the Esper Morphogenetic Platform. The Kasmina subsystem consists of distributed KasminaSeed modules responsible for the low-level mechanics of monitoring neural network health, executing their own adaptation lifecycle, and safely integrating ("grafting") new computational capacity into a live host network.

This specification serves as the canonical reference for the implemented system. The scope is strictly limited to the operational mechanics of the KasminaSeed; it does not cover the strategic decision-making policies or the coordination logic, which are the exclusive domain of Tamiyo (TamiyoController).

### **1.2. Architectural Goals & Principles**

The Kasmina architecture is designed to adhere to the following core principles:

* **Surgical Precision:** Adaptations must be targeted at specific, verifiable computational bottlenecks. By isolating and modifying only the underperforming components, Kasmina avoids disrupting well-functioning parts of the network.  
* **Operational Safety:** The primary goal is to *do no harm*. All interventions are executed via a multi-stage, gated lifecycle that tests new components in isolation before they are allowed to influence the network's gradients or outputs.  
* **Modularity & Extensibility:** The system must be composed of clearly defined, pluggable components (e.g., Grafting Strategies) to facilitate experimentation and future evolution.  
* **Separation of Concerns:** Kasmina handles the *how* (the mechanics of adaptation). The strategic *what*, *when*, and *where* are the exclusive responsibilities of the Tamiyo controller. The KasminaSeed is a predictable, deterministic operator that executes commands given to it by the controller.

## **2. System Architecture**

The Kasmina subsystem uses a **chunked architecture** to monitor and adapt neural networks. This design allows for efficient, parallel processing of large activation tensors while maintaining the integrity of the original network structure.

### **2.1. Architectural Model: The Chunked Architecture**

The foundational principle of the Kasmina architecture is the partitioning of a layer's activation tensor into multiple, independently monitored **chunks**. This strikes an optimal balance between the surgical precision of a true per-node model and the computational efficiency required for large-scale networks.

* **Operator-Controlled Granularity:** An operator has direct control over the level of precision via the --seeds_per_layer parameter, which determines how many chunks a layer is divided into.  
  * **Ultra-fine (Per-Node) Mode:** Setting seeds_per_layer equal to the layer's hidden_dim results in a chunk size of 1, providing maximum diagnostic precision for detecting "dead neurons".  
  * **Coarse Mode:** Setting seeds_per_layer to a small number (e.g., 4 or 8) provides efficient, high-level monitoring suitable for very large networks.  
* **Data Flow (Split -> Process -> Concatenate):** During a forward pass, the activation tensor of a layer is split into non-overlapping chunks. Each chunk is passed to its corresponding KasminaSeed for processing. The outputs from all seeds are then concatenated back together, re-forming the full activation tensor with perfect dimensionality preservation. This ensures that the operations of one seed are structurally isolated from all others.

### **2.2. Visual Data Flow**

The data flow within a Kasmina-enabled layer is deterministic and precise, ensuring perfect structural integrity.

graph TD  
    A[Activation Vector<br>(batch_size, hidden_dim)] --> B{torch.split<br>into N chunks};  
    B --> C1[Chunk 0<br>(batch_size, chunk_size_0)];  
    B --> C2[...];  
    B --> C3[Chunk N-1<br>(batch_size, chunk_size_N-1)];  

    C1 --> D1["KasminaSeed(layer, 0)<br>Processes Chunk 0"];  
    C2 --> D2["..."];  
    C3 --> D3["KasminaSeed(layer, N-1)<br>Processes Chunk N-1"];  
      
    D1 --> E1[Processed Chunk 0];  
    D2 --> E2["..."];  
    D3 --> E3[Processed Chunk N-1];  
      
    E1 --> F{torch.cat(dim=1)};  
    E2 --> F;  
    E3 --> F;  
      
    F --> G[Final Output Vector<br>(batch_size, hidden_dim)];

This diagram illustrates the process: an incoming tensor is deconstructed into smaller, manageable chunks, each handled by a specialist seed, before being perfectly reconstructed. This mechanism is the core of Kasmina's ability to perform parallel monitoring and intervention without compromising the network's structural integrity.

## **3. Core Component: KasminaSeed**

The Kasmina architecture is implemented entirely by the KasminaSeed module. There are no other components within the Kasmina subsystem. These distributed agents are coordinated directly by the Tamiyo controller.

### **3.1. KasminaSeed (The Kasmina Operator)**

The KasminaSeed is the core atomic unit of the Kasmina architecture. An instance of this module is created for each chunk in a monitored layer. It is a stateful agent that executes the full lifecycle of adaptation based on direct commands from Tamiyo.

* **Responsibilities:**  
  * **State Management:** Each seed is a self-contained state machine, progressing through the canonical 9-stage lifecycle. Its internal state dictates its behaviour in the computational graph.  
  * **Telemetry Generation:** In its DORMANT state, it buffers its assigned activations. At the end of each epoch, it calculates and pushes a rich, multi-metric health signal directly to Tamiyo (or via an event bus Tamiyo subscribes to).  
  * **Child Network Management:** When commanded to germinate by Tamiyo, it manages the initialisation of its child network (the specified blueprint).  
  * **Grafting Execution:** It executes the GraftingStrategy specified by Tamiyo to smoothly and safely blend its child network's output into the main computational graph.  
* **Interaction with Controller:** Each KasminaSeed instance must be initialized with a handle or reference to the Tamiyo controller instance. It uses this handle for all "upwards" communication, such as registering itself, pushing telemetry, and accessing its activation buffer (which is managed by Tamiyo).

## **4. Telemetry and Control Interface**

The interface between the Kasmina seeds (KasminaSeed instances) and the Tamiyo controller is designed for a clean separation of concerns, enabling a responsive, event-driven control loop.

### **4.1. Health Signal (Kasmina → Tamiyo)**

The primary information pathway from the Kasmina seeds to Tamiyo is the chunk health signal.

* **Push-Based Model:** The target architecture is a **push-based** model. At the end of each training epoch, every DORMANT KasminaSeed proactively calculates its health and pushes a report to an event bus that Tamiyo subscribes to. This provides Tamiyo with a complete, real-time health map of the network.  
* **Multi-Metric Signal:** The health signal is a dictionary of diagnostic metrics, allowing Tamiyo to understand the *nature* of a bottleneck. This includes:  
  * chunk_variance: Indicates a "stuck" or "dead" chunk.  
  * dead_node_ratio: Measures the proportion of inactive neurons within the chunk.  
  * avg_inter_node_correlation: Suggests functional redundancy.  
  * activity_entropy: Indicates how uniformly the chunk's nodes are being utilized.  
  * drift_magnitude: Measures local training instability.

### **4.2. Control Commands (Tamiyo → Kasmina)**

The primary control pathway is a direct command from Tamiyo to a specific KasminaSeed instance. Tamiyo maintains the registry of all seeds and can therefore address them directly.

* **KasminaSeed.request_germination(blueprint_id, grafting_strategy):** This is the method Tamiyo calls directly on a specific seed to initiate an adaptation. Tamiyo provides the full specification: *what* to grow (blueprint_id) and *how* to integrate it (grafting_strategy). The seed then transitions its internal state to GERMINATED and awaits its turn in the training queue managed by Tamiyo.  
* **KasminaSeed.cancel_germination():** This method allows Tamiyo to intelligently retract a previous request for a seed that is currently in the GERMINATED or TRAINING state. The seed will then transition its state to CANCELLED and subsequently back to DORMANT.

The asynchronous interaction between the two systems is crucial for efficiency and responsiveness.

sequenceDiagram  
    participant Kasmina (Seeds)  
    participant EventBus  
    participant Tamiyo

    loop Every Epoch  
        Kasmina (Seeds)-->>EventBus: Push Health Reports  
    end  
      
    Tamiyo->>EventBus: Consume Health Reports  
    Note over Tamiyo: Analyzes data, detects plateau,<br>identifies critical node 'A', adds its<br>seed to internal germination queue.  
      
    alt Training Slot is Free  
      Tamiyo->>Kasmina (Seed A): request_germination(bp_X, gs_Y)  
      Note over Kasmina (Seed A): State -> GERMINATED -> TRAINING  
    end

    Note over Tamiyo: A different seed, 'B', is in the queue.<br>New health reports show its node has self-corrected.  
    Tamiyo->>Kasmina (Seed B): cancel_germination()  
    Note over Kasmina (Seed B): State -> CANCELLED -> DORMANT

## **5. The Authoritative Seed Lifecycle**

The lifecycle is the core process model for every adaptation, ensuring a balance of safety and effectiveness. It is executed by the KasminaSeed and orchestrated by Tamiyo. Each stage represents a gate that must be passed before proceeding.

| State | Emoji | Trigger | Key Behavior | Risks Mitigated by this State | Next State |
| :---- | :---- | :---- | :---- | :---- | :---- |
| **DORMANT** | ⚪ | Initial state | Buffers activations, pushes health reports. Identity pass-through. | Inaction; failing to detect a critical bottleneck. | GERMINATED |
| **GERMINATED** | 🌱 | request_germination() from Tamiyo | "Parking lot" state. Awaits promotion from the training queue (managed by Tamiyo). | Resource contention from training multiple seeds at once; training instability. | TRAINING or CANCELLED |
| **TRAINING** | 🧑‍🏫 | Promoted from queue by Tamiyo | Learns a self-supervised reconstruction task (MSE). **Zero impact** on main network's forward pass. | An unstable or poorly initialized blueprint affecting the live model's performance. | GRAFTING, CULLED, or CANCELLED |
| **GRAFTING** | 🔗 | Passes reconstruction "soft-test" | Blends child network's output with the original activation via a smooth alpha ramp. | Sudden performance drops or gradient shock caused by an abrupt change in the computational graph. | STABILIZATION |
| **STABILIZATION** | 🛠️ | alpha ramp complete | Parameters are temporarily frozen to allow network dynamics (e.g., BatchNorm stats) to settle. | Inaccurate performance evaluation due to an unsettled network state. | EVALUATING |
| **EVALUATING** | 🔬 | Stabilization complete | Measures impact on global validation metrics without any training to get a clean performance signal. | Wasting resources fine-tuning a harmful blueprint. | FINE-TUNING or CULLED |
| **FINE-TUNING** | 📻 | Positive evaluation | Switches training to the main task loss (e.g., Cross-Entropy) to align with the global goal. | A blueprint that is good at reconstruction but useless for the main task. | FOSSILIZED or CULLED |
| **FOSSILIZED** | 🦴 | Demonstrates global improvement | Parameters are permanently frozen. The adaptation is successful and permanent. | N/A (Success state) | *Terminal* |
| **CULLED** | 🥀 | Fails a performance/stability gate | **Failure state.** Deactivated due to poor performance. The slot is placed under a temporary embargo by Tamiyo. | "Thrashing" - repeatedly trying to fix a persistently unstable part of the network. | DORMANT |
| **CANCELLED** | 🔄 | cancel_germination() from Tamiyo | **Stop state.** Immediately ceases all activity and discards any trained child network. Occurs before parent net is impacted. | Wasting compute on a now-unnecessary adaptation; occupying a training slot needed elsewhere. | DORMANT |
| **ROLLED_BACK** | 🛑 | Tamiyo detects a critical failure | **Failure state.** The adaptation is rolled back to the last stable checkpoint. The seed is frozen and does not return to DORMANT. | A catastrophic failure that requires intervention by Tolaria. | **TERMINAL** |

## **6. Pluggable Grafting Strategies**

Grafting is the critical and delicate process of integrating the new seed. The KasminaSeed implements a pluggable strategy pattern to allow for different integration behaviors, based on the strategy name passed to it by Tamiyo.

* **FixedRampGrafting:** The baseline, most predictable strategy. It increases the blending factor alpha linearly over a fixed number of steps. It is used when the network is stable and a predictable integration is desired.  
* **PerformanceLinkedGrafting:** An optimistic strategy that accelerates grafting if the seed's self-supervised reconstruction loss improves quickly. This can speed up the integration of good seeds, but carries the risk of rewarding behavior (good reconstruction) that may not align with the final task performance.  
* **DriftControlledGrafting:** A key safety strategy designed for unstable networks. It constantly monitors model weight drift (a proxy for stability) and will **automatically pause** the grafting process if drift exceeds a safe threshold. It ensures that new components are not introduced while the host network is already in a turbulent state.  
* **GradNormGatedGrafting:** Another crucial safety strategy. It monitors the norm of the model's gradients and **pauses** grafting if gradients are exploding or vanishing. This prevents integration during periods of acute training instability.

## **7. API Contracts & Data Structures**

Key data structures and interfaces are defined to ensure stable, versioned interaction between the Kasmina operators and the Tamiyo controller.

```python
# --- Core Component Interface ---

class KasminaSeed(nn.Module):  
    """A stateful agent that monitors a chunk and executes the adaptation lifecycle."""

    def __init__(self, seed_id: tuple, chunk_dim: int, controller: "TamiyoController", **kwargs):  
        ...

    def forward(self, x: torch.Tensor, y: torch.Tensor | None = None) -> torch.Tensor: ...  
      
    def push_health_signal(self) -> None:   
        """Calculates health metrics and pushes them to the controller."""  
        ...

    def request_germination(self, blueprint_id: str, grafting_strategy: str) -> bool:  
        """Called by Tamiyo to initiate the lifecycle. Transitions state to GERMINATED. Returns success."""  
        ...

    def cancel_germination(self) -> bool:  
        """Called by Tamiyo to cancel a queued/training request. Transitions state to CANCELLED. Returns success."""  
        ...  
    # ... internal lifecycle methods for each state

# --- Controller Interface (for context) ---

class TamiyoController:  
    """The central controller, responsible for strategy and coordination."""  
    def **init**(self):  
        self.seed_registry: dict[tuple, KasminaSeed] = {}  
        self.activation_buffers: dict[tuple, deque] = {}  
        self.germination_queue: list[tuple] = []  
        # ...  

    def register_seed(self, seed: KasminaSeed) -> None:  
        """Adds a new seed to the registry upon network creation."""  
        ...

# --- Configuration & Strategy Interfaces ---

@dataclass(frozen=True)  
class GraftingConfig:  
    """Immutable configuration for all grafting strategies and lifecycle timings."""  
    fixed_steps: int = 30  
    high_drift_threshold: float = 0.12  
    grad_norm_lower: float = 0.1  
    grad_norm_upper: float = 1.0  
    # ... other thresholds for stabilization, fine-tuning patience, etc.

class GraftingStrategy(ABC):  
    """Abstract base class for all integration strategies."""  
    def **init**(self, seed: KasminaSeed, config: GraftingConfig): ...  

    @abstractmethod  
    def update(self) -> float: # Returns the new alpha value for the current step  
        ...
```
